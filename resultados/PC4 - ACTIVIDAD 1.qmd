---
title: "M√©todos de agrupamiento usando Machine Learning"
format: html
---

# **Actividad usando la data del repositorio 13**

### Instalar y cargar los paquetes

```{r}
install.packages("factoextra")
install.packages("cluster")
```

```{r}
library(factoextra)
library(cluster)
library(here)
library(rio)
library(tidyverse)
```

# 1 An√°lisis de agrupamiento herarquico (Hierarchical Clustering)

## 1.1 Sobre el problema para esta sesi√≥n

El objetivo de este ejercicio es aplicar el m√©todo de agrupamiento jer√°rquico para identificar grupos de pacientes que compartan caracter√≠sticas similares en cuanto a su estado de salud basal, lo que permitir√° proponer posibles categor√≠as de riesgo o patrones cl√≠nicos diferenciados.

## 1.2 El dataset para esta sesi√≥n

Para ilustrar el proceso de an√°lisis usaremos el dataset llamado `hemo_data` el cual contiene 160 observaciones.

### 1.2.1 Importando los datos

```{r}
hemo_data <- import(here("data", "s13_hemodialisis.csv"))
```

El c√≥digo utilizado importa la base de datos *s13_hemodialisis.csv* al entorno de trabajo de R. Para ello, la funci√≥n `here()` se encarga de ubicar correctamente el archivo dentro de la carpeta del proyecto, evitando errores por rutas mal definidas. Luego, mediante `import()`, el contenido del archivo es le√≠do y convertido en un objeto tipo data frame. De esta manera, toda la informaci√≥n cl√≠nica y anal√≠tica de los pacientes queda almacenada en el objeto `hemo_data`, listo para su an√°lisis estad√≠stico posterior.

## 1.3 Preparaci√≥n de los datos

### 1.3.1 Solo datos num√©ricos

```{r}
hemo_data_1 = hemo_data |> 
  select(-Sexo, -Enfermedad_Renal) |> 
  column_to_rownames("id")
```

En este bloque, se genera un nuevo conjunto de datos llamado `hemo_data_1` a partir del archivo original. Primero, se eliminan las variables *Sexo* y *Enfermedad_Renal*, probablemente porque no se usar√°n en los an√°lisis posteriores o porque se busca trabajar solo con variables num√©ricas. Luego, se transforma la columna `id` en el nombre de las filas mediante `column_to_rownames()`. Con esto, cada registro queda identificado por su propio c√≥digo de paciente, lo que facilita procedimientos como an√°lisis multivariados o matrices de distancia.

### 1.3.2 La importancia de estandarizar

```{r}
hemo_data_escalado = scale(hemo_data_1)
```

En esta l√≠nea, el objeto `hemo_data_1` es estandarizado mediante la funci√≥n `scale()`, generando una nueva base llamada `hemo_data_escalado`. Este procedimiento convierte todas las variables num√©ricas a una misma escala, centrando cada una en su media y ajust√°ndola seg√∫n su desviaci√≥n est√°ndar. De este modo, todas las variables quedan comparables entre s√≠, evitando que aquellas con valores num√©ricamente mayores tengan m√°s influencia en los an√°lisis posteriores, especialmente en m√©todos multivariados como el an√°lisis de componentes principales o el clustering.

Un vistazo a los datos antes del escalamiento:

```{r}
head(hemo_data_1)
```

El comando `head(hemo_data_1)` muestra las primeras filas del objeto `hemo_data_1`. Su funci√≥n es ofrecer una vista preliminar del contenido del data frame despu√©s de haber eliminado las variables categ√≥ricas y haber asignado la columna `id` como nombre de las filas. Esta visualizaci√≥n inicial permite verificar que las transformaciones previas se hayan aplicado correctamente y que los datos est√©n organizados de forma adecuada para los an√°lisis posteriores.

y un vistazo despu√©s del escalamiento:

```{r}
head(hemo_data_escalado)
```

**Interpretaci√≥n**

El resultado presentado corresponde a las primeras filas del objeto `hemo_data_escalado`, es decir, la versi√≥n estandarizada del conjunto de datos. Cada valor num√©rico representa un *z-score*, lo que significa que todas las variables han sido transformadas para tener media cero y desviaci√≥n est√°ndar igual a uno. En esta escala, los valores positivos indican que el paciente se encuentra por encima del promedio de la muestra, mientras que los valores negativos reflejan que est√° por debajo del promedio.

La tabla permite verificar que el proceso de estandarizaci√≥n se aplic√≥ correctamente a todas las variables cl√≠nicas, bioqu√≠micas y urinarias del dataset. Adem√°s, se aprecia que los nombres de las filas coinciden con el identificador de cada paciente, lo que confirma que la estructura generada previamente (`hemo_data_1`) se mantuvo sin alteraciones. Esta vista inicial es √∫til para asegurarse de que la magnitud original de las variables ya no influir√° en los an√°lisis multivariados posteriores, permitiendo compararlas de forma equitativa dentro de m√©todos como PCA o clustering.

## 1.4 C√°lculo de distancias

```{r}
dist_hemo_data <- dist(hemo_data_escalado, method = "euclidean")
```

**Interpretaci√≥n:**

Se calcula la distancia euclidiana entre todos los pacientes incluidos en la base de datos, usando las variables que previamente fueron estandarizadas. Esta distancia act√∫a como un indicador de similitud cl√≠nica global: cuanto menor es la distancia entre dos pacientes, m√°s parecidos son en su perfil bioqu√≠mico y fisiol√≥gico; cuanto mayor es, m√°s diferentes son.

El uso de los datos escalados garantiza que todas las variables contribuyan por igual al c√°lculo, evitando que aquellas con valores m√°s altos de forma natural (como la urea o la creatinina) tengan un peso excesivo.

El resultado es una matriz que resume c√≥mo se relacionan los pacientes entre s√≠ desde un punto de vista multivariado, y constituye un insumo esencial para an√°lisis posteriores como el clustering jer√°rquico, k-means o la construcci√≥n de dendrogramas, donde estas distancias determinan la formaci√≥n de grupos cl√≠nicamente interpretables

## 1.4.1 (opcional) Visualizando las distancias euclidianas con un mapa de calor

```{r}
fviz_dist(dist_hemo_data)
```

**Interpretaci√≥n:**

El gr√°fico corresponde a un heatmap de distancias euclidianas entre los pacientes del estudio, calculadas a partir de todas las variables cl√≠nicas estandarizadas. Cada punto del mapa representa la distancia entre un paciente (eje vertical) y otro (eje horizontal). La escala de colores va de:

-   Rojo: distancias peque√±as ‚Üí pacientes muy similares.

-   Azul: distancias grandes ‚Üí pacientes muy diferentes.

La diagonal roja que cruza el gr√°fico corresponde a la comparaci√≥n de cada paciente consigo mismo, donde la distancia es cero.

Podemos manifestara principales hallazgos:

-   **Aparecen bloques definidos en tonos azulados (distancias grandes):** Estos bloques indican que ciertos grupos de pacientes presentan perfiles cl√≠nicos marcadamente distintos al resto de la poblaci√≥n. Cl√≠nicamente, esto sugiere la presencia de subpoblaciones con caracter√≠sticas particulares, como mayor deterioro renal, diferencias en el nivel de anemia, alteraciones del metabolismo u otros marcadores bioqu√≠micos.

<!-- -->

-   **Existen zonas en tonos rojizos entre algunos pacientes:** Las √°reas m√°s rojizas muestran grupos de pacientes que comparten valores cl√≠nicos similares. Esto puede corresponder a pacientes con un perfil m√°s homog√©neo, ya sea por estadio de enfermedad o por caracter√≠sticas cl√≠nicas comunes.

<!-- -->

-   **La presencia de dos zonas amplias m√°s oscuras (azules) en forma de rect√°ngulos:** Estas regiones indican que hay dos posibles clusters principales de pacientes cuyos perfiles son muy diferentes entre s√≠. Esto suele ser un indicio de que el an√°lisis de clustering posterior (como k-means o clustering jer√°rquico) probablemente identificar√° dos o m√°s grupos cl√≠nicamente diferenciables.

<!-- -->

-   **La mezcla dispersa de tonos claros en otras √°reas:** Sugiere que, entre los dem√°s pacientes, las diferencias no son tan marcadas, lo que indica una variabilidad moderada dentro de la poblaci√≥n.

## 1.5 El m√©todo de agrupamiento: funci√≥n de enlace (linkage)

```{r}
dist_link_hemo_data <- hclust(d = dist_hemo_data, method = "ward.D2")
```

-   Lo que estamos haciendo es organizar a los pacientes seg√∫n su similitud global, considerando todas sus variables cl√≠nicas y bioqu√≠micas de manera conjunta. El m√©todo Ward.D2 intenta que cada grupo formado sea internamente coherente, es decir, que los pacientes de un mismo cl√∫ster realmente compartan caracter√≠sticas cl√≠nicas relevantes. Adem√°s, este m√©todo tiende a producir grupos separados de manera clara, lo cual facilita la interpretaci√≥n m√©dica posterior.

## 1.6 Dendrogramas para la visualizaci√≥n de patrones

Los dendrogramas es una representaci√≥n gr√°fica del √°rbol jer√°rquico generado por la funci√≥n `hclust()`.

```{r}
fviz_dend(dist_link_hemo_data, cex = 0.7)
```

**Interpretaci√≥n:**

-   El dendrograma muestra c√≥mo los pacientes se agrupan seg√∫n la similitud de sus par√°metros cl√≠nicos y bioqu√≠micos. Se observa una divisi√≥n clara en dos grandes grupos, lo que indica que existen dos perfiles cl√≠nicos bien diferenciados dentro de la poblaci√≥n en hemodi√°lisis.

-   Dentro de cada grupo principal aparecen subgrupos m√°s peque√±os, formados por pacientes con caracter√≠sticas a√∫n m√°s similares entre s√≠. En conjunto, el dendrograma evidencia que la muestra no es homog√©nea y que los pacientes presentan patrones cl√≠nicos diferenciados que pueden ser relevantes para el an√°lisis y la interpretaci√≥n cl√≠nica.

## 1.7 ¬øC√∫antos grupos se formaron en el dendrograma?

```{r}
fviz_dend(dist_link_hemo_data, 
          k = 3,
          cex = 0.5,
          k_colors = c("#2E9FDF", "#E7B800", "#FC4E07"),
          color_labels_by_k = TRUE, 
          rect = TRUE)
```

**Interpretaci√≥n:**

El dendrograma coloreado muestra la divisi√≥n de los pacientes en tres cl√∫steres principales, cada uno identificado por un color distinto. Esta segmentaci√≥n se basa en la similitud global de sus par√°metros cl√≠nicos y bioqu√≠micos, previamente estandarizados.

El Cluster 1 (azul) re√∫ne al grupo m√°s numeroso y homog√©neo de pacientes, caracterizado por presentar perfiles muy similares entre s√≠, lo que se refleja en las uniones a baja altura.\
El Cluster 2 (amarillo) representa un subconjunto intermedio, cuyos pacientes comparten caracter√≠sticas cl√≠nicas diferenciadas tanto del grupo azul como del grupo rojo.\
Finalmente, el Cluster 3 (rojo) corresponde a un grupo claramente separado, lo que sugiere un perfil cl√≠nico distinto y posiblemente m√°s espec√≠fico.

La delimitaci√≥n mediante rect√°ngulos facilita visualizar c√≥mo cada grupo est√° bien definido internamente y, al mismo tiempo, diferenciado del resto. En conjunto, este an√°lisis confirma que la poblaci√≥n estudiada no es uniforme y se organiza en tres perfiles cl√≠nicos bien diferenciados, lo cual puede ser √∫til para identificar patrones, estratificar a los pacientes o plantear nuevas hip√≥tesis cl√≠nicas.

# 2 Agrupamiento con el algoritmo K-Means

## 2.1 El problema y dataset para este ejercicio

Usaremos el mismo dataset y el mismo problema que el que empleamos en el ejercicio anterior (para Agrupamiento Jer√°rquico).

## 2.2 Estimando el n√∫mero √≥ptimo de clusters

Primero escalamos los datos:

```{r}
hemo_data_escalado = scale(hemo_data_1)
```

Se realiza la estandarizaci√≥n de todas las variables num√©ricas del conjunto de datos. Esto significa que cada variable es transformada para tener media 0 y desviaci√≥n est√°ndar 1. Este paso es fundamental porque evita que variables con magnitudes naturalmente mayores (como BUN, creatinina o fosfatasa alcalina) dominen el an√°lisis. Al escalarlas, todas las variables aportan el mismo peso al c√°lculo de distancias y a los m√©todos de agrupamiento, permitiendo una comparaci√≥n m√°s justa entre los pacientes y una interpretaci√≥n m√°s fiable de los cl√∫steres.

Ahora graficamos la suma de cuadrados dentro de los gr√°ficos

```{r}
fviz_nbclust(hemo_data_escalado, kmeans, nstart = 25, method = "wss") + 
  geom_vline(xintercept = 3, linetype = 2)
```

**Interpretaci√≥n:**

El gr√°fico muestra el m√©todo del *Within Sum of Squares* (WSS), utilizado para determinar el n√∫mero √≥ptimo de cl√∫steres. La curva evidencia una ca√≠da pronunciada entre 1 y 2 cl√∫steres, seguida de una disminuci√≥n menos marcada al pasar de 2 a 3. A partir del tercer cl√∫ster, la reducci√≥n del WSS se vuelve m√≠nima, indicando que agregar m√°s grupos ya no aporta una mejora significativa en la homogeneidad dentro de los cl√∫steres.

El punto donde la curva comienza a estabilizarse, marcado por la l√≠nea punteada, se√±ala que k = 3 es el n√∫mero √≥ptimo de cl√∫steres para esta poblaci√≥n. Esto respalda la divisi√≥n en tres grupos cl√≠nicamente diferenciados, coherente con el dendrograma previamente analizado.

## 2.3 C√°lculo del agrupamiento k-means

```{r}
set.seed(123)
km_res <- kmeans(hemo_data_escalado, 3, nstart = 25)
```

El an√°lisis k-means con 3 clusters separ√≥ a las observaciones en tres grupos con perfiles hematol√≥gicos distintos. Cada cluster re√∫ne datos que se parecen entre s√≠ y se diferencian de los otros grupos. Esto permite identificar tres patrones o perfiles dentro del conjunto de variables hematol√≥gicas, como niveles m√°s altos, intermedios o m√°s bajos seg√∫n el caso. En resumen, el algoritmo organiz√≥ autom√°ticamente tus datos en tres tipos de perfiles hematol√≥gicos.

```{r}
km_res
```

**Interpretaci√≥n:**

El an√°lisis k-means con 3 clusters mostr√≥ que las observaciones se organizan en tres perfiles cl√≠nicos diferenciados.

**üîµ Cluster 1 (n = 50): Perfil intermedio / relativamente equilibrado.**\
Los valores est√°n cerca del promedio, con ligeras elevaciones en marcadores como PCR, GGT y algunos electrolitos urinarios. Podr√≠a representar un grupo sin alteraciones marcadas, con variaciones leves.

**üü†** **Cluster 2 (n = 30): Perfil m√°s alterado / mayor carga cl√≠nica.**\
Este grupo tiene los valores m√°s altos de inflamaci√≥n (PCR), estr√©s metab√≥lico (AST, ALT, GGT), funci√≥n renal (BUN, creatinina), l√≠pidos, glucosa, HbA1c y da√±o tubular (NAG, A1-microglobulina). Podr√≠a representar a los individuos con peor perfil metab√≥lico, renal e inflamatorio.

üü¢ **Cluster 3 (n = 80): Perfil m√°s saludable o bajo riesgo.**\
Presenta valores m√°s bajos en inflamaci√≥n, da√±o hep√°tico y renal, glucosa y electrolitos urinarios, junto con mejores niveles de HDL y hierro. Podr√≠a corresponder al grupo con mejores condiciones cl√≠nicas generales.

## 2.4 Visualizaci√≥n de los cl√∫steres k-means

```{r}
fviz_cluster(
  km_res,
  data = hemo_data_escalado,
  palette = c("#2E9FDF", "#E7B800", "#FC4E07"),
  ellipse.type = "euclid",
  repel = TRUE,
  ggtheme = theme_minimal()
)
```

El gr√°fico de clusters muestra de forma visual c√≥mo el algoritmo k-means separ√≥ los datos en tres grupos bien definidos. Cada color representa un cluster distinto, y las elipses euclidianas ayudan a identificar el ‚Äúespacio‚Äù que ocupa cada grupo dentro de la variabilidad total de los datos. Se observa que los puntos dentro de cada cluster est√°n relativamente juntos, lo que indica coherencia interna, mientras que los clusters se encuentran separados entre s√≠, reflejando diferencias claras en los perfiles cl√≠nicos.

Se observa que los tres clusters est√°n separados de manera evidente, lo que indica que los pacientes comparten caracter√≠sticas cl√≠nicas y bioqu√≠micas similares dentro de cada grupo, pero difieren de los otros dos. La distancia entre las elipses refleja diferencias reales en los perfiles hematol√≥gicos y metab√≥licos de los pacientes.

En conjunto, esta representaci√≥n confirma que el modelo k-means logr√≥ una segmentaci√≥n consistente y cl√≠nicamente interpretable, al agrupar a los pacientes seg√∫n patrones comunes de sus variables bioqu√≠micas, permitiendo distinguir claramente un perfil m√°s comprometido, uno intermedio y otro m√°s favorable.

# Actividad usando la base "Diabetes"

### Cargamos la base a usar

```{r}
diabetes = import(here("data", "data_diabetes_6.csv"))
```

Indica que se est√° importando un archivo llamado *data_diabetes_6.csv*, ubicado dentro de la carpeta *data*, utilizando la ruta construida autom√°ticamente por la funci√≥n `here()`. El archivo se carga en R como un data frame y se almacena en el objeto diabetes, que luego puede ser utilizado para an√°lisis y manipulaci√≥n de datos.

*En este caso el an√°lisis de agrupamiento herarquico se realizar√° con nuevos c√≥digos para explorar si funcionan similar a los c√≥digos usados en clases.*

## **1. Seleccionar solo las variables num√©ricas**

```{r}
diabetes_num <- diabetes |> 
  dplyr::select(where(is.numeric))
```

El comando crea un nuevo objeto llamado diabetes_num que contiene √∫nicamente las variables num√©ricas del conjunto de datos original *diabetes*. Esto se logra utilizando la funci√≥n `select()` junto con `where(is.numeric)`, que autom√°ticamente identifica todas las columnas cuyo tipo de dato es num√©rico.

El resultado es un data frame m√°s compacto, sin variables categ√≥ricas como `Diabetes_5a`, `IMC_cat` o `Grupo_etario`. En su lugar, incluye solo variables como N√∫m_Embarazo, Glucosa_2h, Presi√≥n_Sangu√≠nea, Pliegue_Tr√≠ceps, Insulina_2h, IMC, Historial_Diabetes y Edad, que corresponden a medidas continuas o discretas relevantes del paciente. Este nuevo data frame es m√°s adecuado para procesos de normalizaci√≥n, c√°lculo de distancias y otras t√©cnicas anal√≠ticas que se aplicar√°n posteriormente en el estudio.

## 2. Estandarizar las variables

```{r}
diabetes_scaled <- scale(diabetes_num)
```

El c√≥digo `diabetes_scaled <- scale(diabetes_num)` transforma todas las variables num√©ricas almacenadas en *diabetes_num* a una escala estandarizada, en la cual cada columna pasa a tener una media igual a 0 y una desviaci√≥n est√°ndar igual a 1. Este proceso, conocido como estandarizaci√≥n o normalizaci√≥n Z-score, es fundamental en los an√°lisis de agrupamiento jer√°rquico, porque evita que variables con unidades o rangos muy grandes dominen la medida de distancia entre observaciones.

En la base *diabetes*, variables como Glucosa_2h, IMC o Insulina_2h pueden tener valores muy distintos entre s√≠; sin estandarizaci√≥n, esas diferencias influir√≠an desproporcionadamente en la formaci√≥n de cl√∫steres. Al aplicar `scale()`, todas las variables quedan en una escala comparable, permitiendo que el an√°lisis jer√°rquico considere su contribuci√≥n en igualdad de condiciones.

El resultado esperado es un nuevo objeto llamado diabetes_scaled, que contiene la misma cantidad de filas que el dataset original, pero con todas las variables expresadas en valores estandarizados. Este objeto es el que se utiliza como entrada para calcular distancias y construir el dendrograma del clustering jer√°rquico, como el mostrado en la imagen previa.

## 3. Matriz de distancias

```{r}
dist_matrix <- dist(diabetes_scaled, method = "euclidean")
```

Se calcula la distancia euclidiana entre todas las observaciones del dataset estandarizado *diabetes_scaled*. El resultado es una matriz de distancias, que indica qu√© tan similares o diferentes son los pacientes. Esta matriz es la base que el algoritmo utilizar√° para formar los cl√∫steres en el an√°lisis jer√°rquico

## 4. Clustering jer√°rquico usando Ward.D2

```{r}
hc <- hclust(dist_matrix, method = "ward.D2")
```

El resultado, almacenado en `hc`, es una estructura que muestra c√≥mo se agrupan progresivamente las observaciones seg√∫n su similitud. El m√©todo *Ward.D2* forma cl√∫steres buscando minimizar la variabilidad interna de cada grupo, por lo que los cl√∫steres obtenidos suelen ser compactos y bien diferenciados. El objeto `hc` contiene la informaci√≥n necesaria para construir el dendrograma, donde se observa el orden en que las observaciones se combinan y la ‚Äúaltura‚Äù a la que se unen, lo cual refleja su nivel de disimilitud.

## 5. Graficar el dendrograma

```{r}
plot(hc, 
     labels = FALSE, 
     hang = -1, 
     main = "Dendrograma - Clustering Jer√°rquico",
     xlab = "Observaciones",
     ylab = "Distancia")
```

El c√≥digo `plot(hc, ...)` genera un dendrograma que muestra visualmente c√≥mo las observaciones del dataset se van agrupando seg√∫n su similitud. En el eje horizontal aparecen las observaciones sin etiquetas, y en el eje vertical se representa la distancia o disimilitud a la que se fusionan los grupos.

En el gr√°fico se observan varias ramas que se unen a diferentes alturas:

-   **Ramas que se unen a baja distancia** indican observaciones muy similares.

-   **Ramas que se unen a mayor distancia** representan grupos m√°s distintos entre s√≠.

## 6. Definir el n√∫mero de cl√∫steres

```{r}
k <- 3
clusters <- cutree(hc, k = k)
table(clusters)
```

El c√≥digo divide el dendrograma en 3 cl√∫steres y asigna cada observaci√≥n al grupo correspondiente. La funci√≥n `cutree()` realiza el corte en el nivel indicado y `table(clusters)` muestra cu√°ntas observaciones quedaron en cada grupo.

El resultado indica que:

-   **Cl√∫ster 1:** 245 observaciones

-   **Cl√∫ster 2:** 425 observaciones

-   **Cl√∫ster 3:** 98 observaciones

Esto significa que, al cortar el dendrograma en tres partes, los pacientes se agrupan en tres conjuntos de distinto tama√±o, reflejando diferentes patrones de similitud en sus variables cl√≠nicas.

## 7. Agregamos los cl√∫steres a la data

```{r}
diabetes_clustered <- diabetes |> 
  mutate(Cluster = clusters)
```

Se agrega al data frame original diabetes una nueva columna llamada Cluster, que contiene el n√∫mero de cl√∫ster asignado a cada observaci√≥n por el an√°lisis jer√°rquico.

El resultado es un dataset ampliado, diabetes_clustered, donde cada paciente conserva todas sus variables originales, pero ahora incluye tambi√©n su pertenencia al cl√∫ster 1, 2 o 3. Esto permite comparar grupos, describir sus caracter√≠sticas y realizar an√°lisis adicionales basados en la clasificaci√≥n obtenida.

## 8. Visualizamos la distribuci√≥n de cada cl√∫ster

```{r}
table(diabetes_clustered$Cluster)
```

El comando `table(diabetes_clustered$Cluster)` muestra cu√°ntas observaciones pertenecen a cada uno de los cl√∫steres asignados. El resultado:

-   **Cl√∫ster 1:** 245 casos

-   **Cl√∫ster 2:** 425 casos

-   **Cl√∫ster 3:** 98 casos

Confirma la distribuci√≥n final de los pacientes en los tres grupos formados por el an√°lisis jer√°rquico. Esto permite visualizar r√°pidamente el tama√±o de cada cl√∫ster y comprobar que el agrupamiento se realiz√≥ correctamente.
